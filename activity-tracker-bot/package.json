// index.js
require('dotenv').config();
const { Client, GatewayIntentBits, SlashCommandBuilder, EmbedBuilder } = require('discord.js');
const { google } = require('googleapis');

class ActivityTrackerBot {
  constructor() {
    this.client = new Client({
      intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages]
    });
    
    this.sheets = google.sheets({ version: 'v4' });
    // Googleèªè¨¼ã®è¨­å®š
    if (process.env.GOOGLE_SERVICE_ACCOUNT_JSON) {
      // JSONå…¨ä½“ãŒç’°å¢ƒå¤‰æ•°ã«ã‚ã‚‹å ´åˆ
      const credentials = JSON.parse(process.env.GOOGLE_SERVICE_ACCOUNT_JSON);
      this.auth = new google.auth.GoogleAuth({
        credentials,
        scopes: ['https://www.googleapis.com/auth/spreadsheets']
      });
    } else {
      // å€‹åˆ¥ã®ç’°å¢ƒå¤‰æ•°ã‚’ä½¿ç”¨ã™ã‚‹å ´åˆ
      this.auth = new google.auth.GoogleAuth({
        credentials: {
          type: 'service_account',
          project_id: process.env.GOOGLE_PROJECT_ID,
          client_email: process.env.GOOGLE_CLIENT_EMAIL,
          private_key: process.env.GOOGLE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
          client_id: process.env.GOOGLE_CLIENT_ID,
          auth_uri: 'https://accounts.google.com/o/oauth2/auth',
          token_uri: 'https://oauth2.googleapis.com/token'
        },
        scopes: ['https://www.googleapis.com/auth/spreadsheets']
      });
    }
    
    this.spreadsheetId = process.env.SPREADSHEET_ID;
    this.setupCommands();
    this.setupEvents();
  }

  async setupCommands() {
    const commands = [
      // æœ¬ç®¡ç†
      new SlashCommandBuilder()
        .setName('book')
        .setDescription('æœ¬ã®ç®¡ç†')
        .addSubcommand(subcommand =>
          subcommand
            .setName('add')
            .setDescription('æœ¬ã‚’è¿½åŠ ')
            .addStringOption(option =>
              option.setName('title').setDescription('ã‚¿ã‚¤ãƒˆãƒ«').setRequired(true))
            .addStringOption(option =>
              option.setName('author').setDescription('ä½œè€…').setRequired(true))
            .addStringOption(option =>
              option.setName('memo').setDescription('å‚™è€ƒ').setRequired(false)))
        .addSubcommand(subcommand =>
          subcommand
            .setName('start')
            .setDescription('èª­ã¿å§‹ã‚ã‚‹')
            .addIntegerOption(option =>
              option.setName('id').setDescription('æœ¬ã®ID').setRequired(true)))
        .addSubcommand(subcommand =>
          subcommand
            .setName('finish')
            .setDescription('èª­ã¿çµ‚ã‚ã‚‹')
            .addIntegerOption(option =>
              option.setName('id').setDescription('æœ¬ã®ID').setRequired(true)))
        .addSubcommand(subcommand =>
          subcommand.setName('list').setDescription('æœ¬ä¸€è¦§')),

      // æ˜ ç”»ç®¡ç†
      new SlashCommandBuilder()
        .setName('movie')
        .setDescription('æ˜ ç”»ã®ç®¡ç†')
        .addSubcommand(subcommand =>
          subcommand
            .setName('add')
            .setDescription('æ˜ ç”»ã‚’è¿½åŠ ')
            .addStringOption(option =>
              option.setName('title').setDescription('ã‚¿ã‚¤ãƒˆãƒ«').setRequired(true))
            .addStringOption(option =>
              option.setName('memo').setDescription('å‚™è€ƒ').setRequired(false)))
        .addSubcommand(subcommand =>
          subcommand
            .setName('watch')
            .setDescription('è¦–è´æ¸ˆã¿ã«ã™ã‚‹')
            .addIntegerOption(option =>
              option.setName('id').setDescription('æ˜ ç”»ã®ID').setRequired(true)))
        .addSubcommand(subcommand =>
          subcommand
            .setName('skip')
            .setDescription('è¦‹é€ƒã—ãŸ')
            .addIntegerOption(option =>
              option.setName('id').setDescription('æ˜ ç”»ã®ID').setRequired(true)))
        .addSubcommand(subcommand =>
          subcommand.setName('list').setDescription('æ˜ ç”»ä¸€è¦§')),

      // æ´»å‹•ç®¡ç†
      new SlashCommandBuilder()
        .setName('activity')
        .setDescription('æ´»å‹•ã®ç®¡ç†')
        .addSubcommand(subcommand =>
          subcommand
            .setName('add')
            .setDescription('æ´»å‹•ã‚’è¿½åŠ ')
            .addStringOption(option =>
              option.setName('content').setDescription('æ´»å‹•å†…å®¹').setRequired(true))
            .addStringOption(option =>
              option.setName('memo').setDescription('å‚™è€ƒ').setRequired(false)))
        .addSubcommand(subcommand =>
          subcommand
            .setName('done')
            .setDescription('å®Ÿè¡Œæ¸ˆã¿ã«ã™ã‚‹')
            .addIntegerOption(option =>
              option.setName('id').setDescription('æ´»å‹•ã®ID').setRequired(true)))
        .addSubcommand(subcommand =>
          subcommand
            .setName('skip')
            .setDescription('ã‚„ã‚Šé€ƒã—ãŸ')
            .addIntegerOption(option =>
              option.setName('id').setDescription('æ´»å‹•ã®ID').setRequired(true)))
        .addSubcommand(subcommand =>
          subcommand.setName('list').setDescription('æ´»å‹•ä¸€è¦§')),

      // æ—¥å ±
      new SlashCommandBuilder()
        .setName('report')
        .setDescription('æ—¥å ±ã‚’è¨˜éŒ²')
        .addStringOption(option =>
          option.setName('category').setDescription('ã‚«ãƒ†ã‚´ãƒª').setRequired(true)
            .addChoices(
              { name: 'æœ¬', value: 'book' },
              { name: 'æ˜ ç”»', value: 'movie' },
              { name: 'æ´»å‹•', value: 'activity' }
            ))
        .addIntegerOption(option =>
          option.setName('id').setDescription('å¯¾è±¡ã®ID').setRequired(true))
        .addStringOption(option =>
          option.setName('content').setDescription('å†…å®¹').setRequired(true))
    ];

    this.client.on('ready', async () => {
      console.log(`${this.client.user.tag} ã§ãƒ­ã‚°ã‚¤ãƒ³ã—ã¾ã—ãŸï¼`);
      
      try {
        await this.client.application.commands.set(commands);
        console.log('ã‚³ãƒžãƒ³ãƒ‰ã‚’ç™»éŒ²ã—ã¾ã—ãŸ');
      } catch (error) {
        console.error('ã‚³ãƒžãƒ³ãƒ‰ç™»éŒ²ã‚¨ãƒ©ãƒ¼:', error);
      }
    });
  }

  setupEvents() {
    this.client.on('interactionCreate', async interaction => {
      if (!interaction.isChatInputCommand()) return;

      try {
        const { commandName } = interaction;
        
        switch (commandName) {
          case 'book':
            await this.handleBookCommand(interaction);
            break;
          case 'movie':
            await this.handleMovieCommand(interaction);
            break;
          case 'activity':
            await this.handleActivityCommand(interaction);
            break;
          case 'report':
            await this.handleReportCommand(interaction);
            break;
        }
      } catch (error) {
        console.error('ã‚¨ãƒ©ãƒ¼:', error);
        await interaction.reply({ content: 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚', ephemeral: true });
      }
    });
  }

  async handleBookCommand(interaction) {
    const subcommand = interaction.options.getSubcommand();
    
    switch (subcommand) {
      case 'add':
        const title = interaction.options.getString('title');
        const author = interaction.options.getString('author');
        const memo = interaction.options.getString('memo') || '';
        
        const bookId = await this.addBook(title, author, memo);
        await interaction.reply(`ðŸ“š æœ¬ã‚’è¿½åŠ ã—ã¾ã—ãŸï¼\nID: ${bookId}\nã‚¿ã‚¤ãƒˆãƒ«: ${title}\nä½œè€…: ${author}`);
        break;
      
      case 'start':
        const startId = interaction.options.getInteger('id');
        await this.startReading(startId);
        await interaction.reply(`ðŸ“– èª­æ›¸ã‚’é–‹å§‹ã—ã¾ã—ãŸï¼é ‘å¼µã£ã¦ï¼`);
        break;
      
      case 'finish':
        const finishId = interaction.options.getInteger('id');
        await this.finishReading(finishId);
        await interaction.reply(`âœ… èª­äº†ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼ðŸŽ‰ ã¾ãŸæ¬¡ã®æœ¬ã‚‚æ¥½ã—ã¿ã§ã™ã­ï¼`);
        break;
      
      case 'list':
        const books = await this.getBooks();
        const embed = new EmbedBuilder()
          .setTitle('ðŸ“š æœ¬ä¸€è¦§')
          .setColor('#0099ff')
          .setDescription(books.length > 0 ? books.join('\n') : 'ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹æœ¬ã¯ã‚ã‚Šã¾ã›ã‚“');
        
        await interaction.reply({ embeds: [embed] });
        break;
    }
  }

  async handleMovieCommand(interaction) {
    const subcommand = interaction.options.getSubcommand();
    
    switch (subcommand) {
      case 'add':
        const title = interaction.options.getString('title');
        const memo = interaction.options.getString('memo') || '';
        
        const movieId = await this.addMovie(title, memo);
        await interaction.reply(`ðŸŽ¬ æ˜ ç”»ã‚’è¿½åŠ ã—ã¾ã—ãŸï¼\nID: ${movieId}\nã‚¿ã‚¤ãƒˆãƒ«: ${title}`);
        break;
      
      case 'watch':
        const watchId = interaction.options.getInteger('id');
        await this.watchMovie(watchId);
        await interaction.reply(`ðŸŽ¬ è¦–è´æ¸ˆã¿ã«ã—ã¾ã—ãŸï¼é¢ç™½ã‹ã£ãŸã§ã™ã‹ï¼Ÿ`);
        break;
      
      case 'skip':
        const skipId = interaction.options.getInteger('id');
        await this.skipMovie(skipId);
        await interaction.reply(`ðŸ˜… è¦‹é€ƒã—ã¦ã—ã¾ã„ã¾ã—ãŸã­ã€‚ã¾ãŸæ©Ÿä¼šãŒã‚ã£ãŸã‚‰è¦‹ã¦ã¿ã¦ãã ã•ã„ï¼`);
        break;
      
      case 'list':
        const movies = await this.getMovies();
        const embed = new EmbedBuilder()
          .setTitle('ðŸŽ¬ æ˜ ç”»ä¸€è¦§')
          .setColor('#ff6b6b')
          .setDescription(movies.length > 0 ? movies.join('\n') : 'ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹æ˜ ç”»ã¯ã‚ã‚Šã¾ã›ã‚“');
        
        await interaction.reply({ embeds: [embed] });
        break;
    }
  }

  async handleActivityCommand(interaction) {
    const subcommand = interaction.options.getSubcommand();
    
    switch (subcommand) {
      case 'add':
        const content = interaction.options.getString('content');
        const memo = interaction.options.getString('memo') || '';
        
        const activityId = await this.addActivity(content, memo);
        await interaction.reply(`ðŸŽ¯ æ´»å‹•ã‚’è¿½åŠ ã—ã¾ã—ãŸï¼\nID: ${activityId}\nå†…å®¹: ${content}`);
        break;
      
      case 'done':
        const doneId = interaction.options.getInteger('id');
        await this.doneActivity(doneId);
        await interaction.reply(`âœ… æ´»å‹•ã‚’å®Œäº†ã—ã¾ã—ãŸï¼ãŠç–²ã‚Œæ§˜ã§ã—ãŸï¼ðŸŽ‰`);
        break;
      
      case 'skip':
        const skipId = interaction.options.getInteger('id');
        await this.skipActivity(skipId);
        await interaction.reply(`ðŸ˜… ä»Šå›žã¯è¦‹é€ã‚Šã¾ã—ãŸã­ã€‚ã¾ãŸæ©Ÿä¼šãŒã‚ã‚Œã°ãƒãƒ£ãƒ¬ãƒ³ã‚¸ã—ã¦ã¿ã¦ãã ã•ã„ï¼`);
        break;
      
      case 'list':
        const activities = await this.getActivities();
        const embed = new EmbedBuilder()
          .setTitle('ðŸŽ¯ æ´»å‹•ä¸€è¦§')
          .setColor('#4ecdc4')
          .setDescription(activities.length > 0 ? activities.join('\n') : 'ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹æ´»å‹•ã¯ã‚ã‚Šã¾ã›ã‚“');
        
        await interaction.reply({ embeds: [embed] });
        break;
    }
  }

  async handleReportCommand(interaction) {
    const category = interaction.options.getString('category');
    const id = interaction.options.getInteger('id');
    const content = interaction.options.getString('content');
    
    await this.addDailyReport(category, id, content);
    await interaction.reply(`ðŸ“ æ—¥å ±ã‚’è¨˜éŒ²ã—ã¾ã—ãŸï¼ä»Šæ—¥ã‚‚é ‘å¼µã‚Šã¾ã—ãŸã­âœ¨`);
  }

  // Google Sheetsæ“ä½œãƒ¡ã‚½ãƒƒãƒ‰
  async getNextId(sheetName) {
    const auth = await this.auth.getClient();
    const response = await this.sheets.spreadsheets.values.get({
      auth,
      spreadsheetId: this.spreadsheetId,
      range: `${sheetName}!A:A`
    });
    
    const values = response.data.values || [];
    return values.length; // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’å«ã‚€ã®ã§ã€æ¬¡ã®IDã«ãªã‚‹
  }

  async addBook(title, author, memo) {
    const auth = await this.auth.getClient();
    const id = await this.getNextId('books_master');
    const now = new Date().toISOString().replace('T', ' ').slice(0, 19);
    
    await this.sheets.spreadsheets.values.append({
      auth,
      spreadsheetId: this.spreadsheetId,
      range: 'books_master!A:G',
      valueInputOption: 'RAW',
      resource: {
        values: [[id, now, title, author, memo, 'registered', '']]
      }
    });
    
    return id;
  }

  async startReading(id) {
    const auth = await this.auth.getClient();
    const startDate = new Date().toISOString().slice(0, 10);
    
    // IDã«è©²å½“ã™ã‚‹è¡Œã‚’è¦‹ã¤ã‘ã¦æ›´æ–°
    const response = await this.sheets.spreadsheets.values.get({
      auth,
      spreadsheetId: this.spreadsheetId,
      range: 'books_master!A:G'
    });
    
    const values = response.data.values || [];
    const rowIndex = values.findIndex(row => row[0] == id);
    
    if (rowIndex !== -1) {
      await this.sheets.spreadsheets.values.update({
        auth,
        spreadsheetId: this.spreadsheetId,
        range: `books_master!F${rowIndex + 1}:G${rowIndex + 1}`,
        valueInputOption: 'RAW',
        resource: {
          values: [['reading', startDate]]
        }
      });
    }
  }

  async finishReading(id) {
    const auth = await this.auth.getClient();
    const finishDate = new Date().toISOString().slice(0, 10);
    
    const response = await this.sheets.spreadsheets.values.get({
      auth,
      spreadsheetId: this.spreadsheetId,
      range: 'books_master!A:G'
    });
    
    const values = response.data.values || [];
    const rowIndex = values.findIndex(row => row[0] == id);
    
    if (rowIndex !== -1) {
      await this.sheets.spreadsheets.values.update({
        auth,
        spreadsheetId: this.spreadsheetId,
        range: `books_master!F${rowIndex + 1}:G${rowIndex + 1}`,
        valueInputOption: 'RAW',
        resource: {
          values: [['finished', finishDate]]
        }
      });
    }
  }

  async getBooks() {
    const auth = await this.auth.getClient();
    const response = await this.sheets.spreadsheets.values.get({
      auth,
      spreadsheetId: this.spreadsheetId,
      range: 'books_master!A:G'
    });
    
    const values = response.data.values || [];
    return values.slice(1).map(row => {
      const [id, date, title, author, memo, status] = row;
      const statusEmoji = {
        'registered': 'ðŸ“‹',
        'reading': 'ðŸ“–',
        'finished': 'âœ…',
        'abandoned': 'âŒ'
      };
      
      return `${statusEmoji[status] || 'ðŸ“‹'} [${id}] ${title} - ${author} (${status})`;
    });
  }

  async addMovie(title, memo) {
    const auth = await this.auth.getClient();
    const id = await this.getNextId('movies_master');
    const now = new Date().toISOString().replace('T', ' ').slice(0, 19);
    
    await this.sheets.spreadsheets.values.append({
      auth,
      spreadsheetId: this.spreadsheetId,
      range: 'movies_master!A:F',
      valueInputOption: 'RAW',
      resource: {
        values: [[id, now, title, memo, 'want_to_watch', now.slice(0, 10)]]
      }
    });
    
    return id;
  }

  async watchMovie(id) {
    await this.updateMovieStatus(id, 'watched');
  }

  async skipMovie(id) {
    await this.updateMovieStatus(id, 'missed');
  }

  async updateMovieStatus(id, status) {
    const auth = await this.auth.getClient();
    const date = new Date().toISOString().slice(0, 10);
    
    const response = await this.sheets.spreadsheets.values.get({
      auth,
      spreadsheetId: this.spreadsheetId,
      range: 'movies_master!A:F'
    });
    
    const values = response.data.values || [];
    const rowIndex = values.findIndex(row => row[0] == id);
    
    if (rowIndex !== -1) {
      await this.sheets.spreadsheets.values.update({
        auth,
        spreadsheetId: this.spreadsheetId,
        range: `movies_master!E${rowIndex + 1}:F${rowIndex + 1}`,
        valueInputOption: 'RAW',
        resource: {
          values: [[status, date]]
        }
      });
    }
  }

  async getMovies() {
    const auth = await this.auth.getClient();
    const response = await this.sheets.spreadsheets.values.get({
      auth,
      spreadsheetId: this.spreadsheetId,
      range: 'movies_master!A:F'
    });
    
    const values = response.data.values || [];
    return values.slice(1).map(row => {
      const [id, date, title, memo, status] = row;
      const statusEmoji = {
        'want_to_watch': 'ðŸŽ¬',
        'watched': 'âœ…',
        'missed': 'ðŸ˜…'
      };
      
      return `${statusEmoji[status] || 'ðŸŽ¬'} [${id}] ${title} (${status})`;
    });
  }

  async addActivity(content, memo) {
    const auth = await this.auth.getClient();
    const id = await this.getNextId('activities_master');
    const now = new Date().toISOString().replace('T', ' ').slice(0, 19);
    
    await this.sheets.spreadsheets.values.append({
      auth,
      spreadsheetId: this.spreadsheetId,
      range: 'activities_master!A:F',
      valueInputOption: 'RAW',
      resource: {
        values: [[id, now, content, memo, 'planned', now.slice(0, 10)]]
      }
    });
    
    return id;
  }

  async doneActivity(id) {
    await this.updateActivityStatus(id, 'done');
  }

  async skipActivity(id) {
    await this.updateActivityStatus(id, 'skipped');
  }

  async updateActivityStatus(id, status) {
    const auth = await this.auth.getClient();
    const date = new Date().toISOString().slice(0, 10);
    
    const response = await this.sheets.spreadsheets.values.get({
      auth,
      spreadsheetId: this.spreadsheetId,
      range: 'activities_master!A:F'
    });
    
    const values = response.data.values || [];
    const rowIndex = values.findIndex(row => row[0] == id);
    
    if (rowIndex !== -1) {
      await this.sheets.spreadsheets.values.update({
        auth,
        spreadsheetId: this.spreadsheetId,
        range: `activities_master!E${rowIndex + 1}:F${rowIndex + 1}`,
        valueInputOption: 'RAW',
        resource: {
          values: [[status, date]]
        }
      });
    }
  }

  async getActivities() {
    const auth = await this.auth.getClient();
    const response = await this.sheets.spreadsheets.values.get({
      auth,
      spreadsheetId: this.spreadsheetId,
      range: 'activities_master!A:F'
    });
    
    const values = response.data.values || [];
    return values.slice(1).map(row => {
      const [id, date, content, memo, status] = row;
      const statusEmoji = {
        'planned': 'ðŸŽ¯',
        'done': 'âœ…',
        'skipped': 'ðŸ˜…'
      };
      
      return `${statusEmoji[status] || 'ðŸŽ¯'} [${id}] ${content} (${status})`;
    });
  }

  async addDailyReport(category, id, content) {
    const auth = await this.auth.getClient();
    const reportId = await this.getNextId('daily_reports');
    const date = new Date().toISOString().slice(0, 10);
    
    await this.sheets.spreadsheets.values.append({
      auth,
      spreadsheetId: this.spreadsheetId,
      range: 'daily_reports!A:E',
      valueInputOption: 'RAW',
      resource: {
        values: [[reportId, date, category, id, content]]
      }
    });
    
    return reportId;
  }

  start() {
    this.client.login(process.env.DISCORD_TOKEN);
  }
}

const bot = new ActivityTrackerBot();
bot.start();
